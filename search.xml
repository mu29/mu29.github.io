<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[Lambda와 SNS로 백그라운드 작업 처리하기]]></title>
      <url>/2020/01/22/sns-lambda-background-processing/</url>
      <content type="html"><![CDATA[<p>스노우 입사 전, 한 달 정도의 여유 기간 동안 <a href="https://mailenglish.co" target="_blank" rel="noopener">영어 학습 뉴스레터 서비스</a>를 만들어 운영을 시작했다. 친구 둘과 나를 포함해 총 세 명이 초기 사용자가 되어 서버 비용을 간신히 충당할 수 있었지만, 한 푼이 아쉬운 상황이라는 데에는 큰 차이가 없었다.</p>
<p>사이드 프로젝트라고 공부도 할 겸 처음 써보는 기술을 몇 개 쓰다 보니, 프론트엔드 개발에 생각보다 시간을 많이 쓰게 되어 백엔드는 익숙한 스택으로 빠르게 개발한 것이 문제라면 문제였다. 서버는 Ruby on Rails로 개발했고, 메일 발송을 백그라운드에서 처리하기 위해 Resque를 사용했다. Google Cloud Platform의 무료 크레딧을 사용하기 위해 App Engine, Cloud SQL, 그리고 Cloud Memorystore를 사용했다. 덕분에 시작부터 서비스 유지비로만 한 달에 $80 정도가 나가는 상황이 됐다.</p>
<h2 id="Lambda"><a href="#Lambda" class="headerlink" title="Lambda"></a>Lambda</h2><p>그러기를 몇 달, 무료 크레딧을 다 사용하고 본격적으로 돈이 빠져나가기 시작하자 머리가 아파졌다. 가장 작은 인스턴스를 사용해도 CPU나 메모리 사용량은 수%를 넘지 못하고 있었다. 서비스 특성상 API 호출이 많지 않기 때문이다. 바로 떠오른 게 Serverless였다. Lambda의 무료 사용량을 다 쓸 정도면 나는 백만장자가 될 게 분명했다. (왜 Cloud Functions가 아니라 Lambda냐고 묻는다면.. 나는 Ruby와 ActiveRecord, ActiveSupport를 사랑하는데, Cloud Functions는 Ruby 런타임을 지원하지 않는다.)</p>
<p>Rails 코드를 재작성하려고 보니, 일반적인 요청 - 응답은 간단했지만, 기존에 Resque와 Redis를 사용하여 백그라운드에서 처리하던 메일이나 슬랙 메시지 발송을 어떻게 수정할지가 문제였다. 구현을 위해 Resque의 대략적인 작동 방식을 생각해보면, 아마 작업을 처리하는데 필요한 인자들과 실행할 작업 이름을 직렬화해 Redis 등의 데이터베이스에 저장하고, 서버에서 일정 시간마다 질의해 작업 이름과 인자를 받아 작업을 실행하는 식일 것이다.</p>
<p>처음에는 Redis 대신 SQS를 사용하려 했지만, <a href="https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-quotas.html#quotas-messages" target="_blank" rel="noopener">메시지가 최대 14일까지만 보존되는 제한</a>이 있었다. 구독 해지 작업을 예약하는 경우, 1년 이용권을 구입한 지 얼마 되지 않아 바로 해지한다면 약 1년 정도 뒤에 작업이 실행되어야 하기 때문에 SQS는 사용하기 어려웠다.</p>
<p>비용을 줄이는 게 목적이고 작업이 Redis를 사용해야 할 정도로 많거나 속도에 민감하지 않기 때문에 직렬화한 작업 데이터는 MySQL에 저장하기로 했다. 서버에서 일정 시간마다 질의하는 부분은 마침 <a href="https://docs.aws.amazon.com/ko_kr/lambda/latest/dg/tutorial-scheduled-events-schedule-expressions.html" target="_blank" rel="noopener">Lambda가 Scheduling을 지원</a>해서 5분마다 작업 대기열을 확인해 실행 시간이 지난 작업을 실행 후 삭제하도록 했다. 아래와 같은 구조로 작동한다고 생각하면 된다.</p>
<p><img src="/2020/01/22/sns-lambda-background-processing/v1.png" alt="Architecture Diagram" style="margin: auto;"></p>
<p>여기까지 작업한 코드는 아래와 같다.</p>
<p><code>app/models/pending_job.rb</code><br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PendingJob</span> &lt; ActiveRecord::Base</span></span><br><span class="line">  <span class="comment"># klass     : string</span></span><br><span class="line">  <span class="comment"># params    : text</span></span><br><span class="line">  <span class="comment"># wait_until: datetime</span></span><br><span class="line">  scope <span class="symbol">:enqueued</span>, -&gt; &#123; where(<span class="symbol">wait_until:</span> <span class="number">0</span>...Time.now) &#125;</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p>
<p>실행할 작업 이름 (<code>klass</code>), 필요한 인자 (<code>params</code>), 그리고 실행 시간 (<code>wait_until</code>)을 저장하는 모델</p>
<p><code>functions/execute_pending_jobs.rb</code><br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handler</span><span class="params">(<span class="symbol">event:</span>, <span class="symbol">context:</span>)</span></span></span><br><span class="line">  PendingJob.enqueued.each <span class="keyword">do</span> <span class="params">|job|</span></span><br><span class="line">    params = JSON.parse(job.params).symbolize_keys</span><br><span class="line">    job.klass.constantize.execute(params)</span><br><span class="line">    job.destroy</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">rescue</span> =&gt; e</span><br><span class="line">  logger = Logger.new(STDERR)</span><br><span class="line">  logger.error e.inspect</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p>
<p>5분마다 작업 대기열을 확인해 실행 시간이 지난 작업을 실행 후 삭제하는 Lambda 함수</p>
<p><code>app/common/base_job.rb</code><br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">Jobs</span></span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">self</span>.<span class="title">schedule</span><span class="params">(<span class="symbol">with:</span>, <span class="symbol">wait_until:</span>)</span></span></span><br><span class="line">      PendingJob.create(</span><br><span class="line">        <span class="symbol">klass:</span> <span class="keyword">self</span>.to_s,</span><br><span class="line">        <span class="symbol">params:</span> with.to_json,</span><br><span class="line">        <span class="symbol">wait_until:</span> wait_until,</span><br><span class="line">      )</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p>
<p><code>app/jobs/send_email_job.rb</code><br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Jobs::SendEmail</span> &lt; Jobs::Base</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">execute</span><span class="params">(<span class="symbol">to:</span>, <span class="symbol">subject:</span>, <span class="symbol">body:</span>)</span></span></span><br><span class="line">    client = Aws::SES::Client.new(<span class="symbol">region:</span> <span class="string">'us-east-1'</span>)</span><br><span class="line">    client.send_email(&#123;</span><br><span class="line">      <span class="symbol">destination:</span> &#123;</span><br><span class="line">        <span class="symbol">to_addresses:</span> [to],</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="symbol">message:</span> &#123;</span><br><span class="line">        <span class="symbol">subject:</span> &#123;</span><br><span class="line">          <span class="symbol">charset:</span> <span class="string">'UTF-8'</span>,</span><br><span class="line">          <span class="symbol">data:</span> subject,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="symbol">body:</span> &#123;</span><br><span class="line">          <span class="symbol">html:</span> &#123;</span><br><span class="line">            <span class="symbol">charset:</span> <span class="string">'UTF-8'</span>,</span><br><span class="line">            <span class="symbol">data:</span> body,</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="symbol">source:</span> <span class="string">'Mailenglish &lt;service@mailenglish.co&gt;'</span>,</span><br><span class="line">    &#125;)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p>
<p>그리고 실제로 메일을 발송하는 작업 코드이다. 아래처럼 사용할 수 있다.</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Jobs::SendEmail.schedule(</span><br><span class="line">  <span class="symbol">with:</span> &#123;</span><br><span class="line">    <span class="symbol">to:</span> <span class="string">'mu29@yeoubi.net'</span>,</span><br><span class="line">    <span class="symbol">subject:</span> <span class="string">'Lorem Ipsum'</span>,</span><br><span class="line">    <span class="symbol">body:</span> <span class="string">'dolor sit amet, consectetur adipiscing elit'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="symbol">wait_until:</span> <span class="number">1</span>.days.from_now,</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h2 id="Simple-Notification-Service"><a href="#Simple-Notification-Service" class="headerlink" title="Simple Notification Service"></a>Simple Notification Service</h2><p>이렇게 문제가 해결되면 좋았겠지만 이 방법은 확장성이 떨어진다. 메일 한 건 발송에는 약 1~2초 정도가 소요되기 때문에 정해진 시간에 한꺼번에 뉴스레터를 발송하면 Lambda의 <a href="https://docs.aws.amazon.com/ko_kr/lambda/latest/dg/limits.html" target="_blank" rel="noopener">900초 실행 시간 제한</a>에 걸리게 된다. (사실 개발할 때는 30초인 줄 알았다. ㅠㅠ) 그래서 <strong>작업을 대기열에서 빼내는 함수</strong>와 <strong>작업을 실행하는 함수</strong>를 분리하기로 했다.</p>
<p><strong>작업을 대기열에서 빼내는 함수</strong>는 앞의 <code>execute_pending_jobs</code>와 내용이 비슷하지만, 작업을 바로 실행하는 대신 SNS 주제에 메시지를 게시한다. <strong>작업을 실행하는 함수</strong>는 SNS 주제를 구독하고, 메시지가 들어오면 그로부터 작업 이름과 인자를 받아내어 작업을 실행한다. 아래와 같은 구조로 작동한다고 생각하면 된다.</p>
<p><img src="/2020/01/22/sns-lambda-background-processing/v2.png" alt="Architecture Diagram" style="margin: auto;"></p>
<p>SNS 주제에는 메시지를 빠르게 게시할 수 있고 순간적으로 많은 메시지가 들어와도 그만큼 많은 Lambda 함수를 실행할 것이기 때문에 다량의 작업을 처리하기에도 무리가 없는 구조라고 판단했다. 변경된 코드는 다음과 같다.</p>
<p><code>app/common/base_job.rb</code><br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">module</span> <span class="title">Jobs</span></span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">self</span>.<span class="title">schedule</span><span class="params">(<span class="symbol">with:</span>, <span class="symbol">wait_until:</span>)</span></span></span><br><span class="line">      PendingJob.create(</span><br><span class="line">        <span class="symbol">klass:</span> <span class="keyword">self</span>.to_s,</span><br><span class="line">        <span class="symbol">params:</span> with.to_json,</span><br><span class="line">        <span class="symbol">wait_until:</span> wait_until,</span><br><span class="line">      )</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">self</span>.<span class="title">perform</span><span class="params">(params, id = <span class="literal">nil</span>)</span></span></span><br><span class="line">      @client <span class="params">||</span>= Aws::SNS::Client.new</span><br><span class="line">      @client.publish(</span><br><span class="line">        <span class="symbol">topic_arn:</span> <span class="string">'SNS 주제'</span>,</span><br><span class="line">        <span class="symbol">message:</span> &#123;</span><br><span class="line">          <span class="symbol">id:</span> id,</span><br><span class="line">          <span class="symbol">klass:</span> <span class="keyword">self</span>.to_s,</span><br><span class="line">          <span class="symbol">params:</span> params.to_json,</span><br><span class="line">        &#125;.to_json,</span><br><span class="line">      )</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p>
<p><code>functions/enqueue_pending_jobs.rb</code><br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handler</span><span class="params">(<span class="symbol">event:</span>, <span class="symbol">context:</span>)</span></span></span><br><span class="line">  PendingJob.enqueued.each <span class="keyword">do</span> <span class="params">|job|</span></span><br><span class="line">    job.klass.constantize.perform(job.params, job.id)</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">rescue</span> =&gt; e</span><br><span class="line">  logger = Logger.new(STDERR)</span><br><span class="line">  logger.error e.inspect</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p>
<p><code>functions/execute_pending_jobs.rb</code><br><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handler</span><span class="params">(<span class="symbol">event:</span>, <span class="symbol">context:</span>)</span></span></span><br><span class="line">  messages = event[<span class="string">'Records'</span>].map <span class="keyword">do</span> <span class="params">|record|</span></span><br><span class="line">    JSON.parse(record[<span class="string">'Sns'</span>][<span class="string">'Message'</span>]).symbolize_keys</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line">  messages.each <span class="keyword">do</span> <span class="params">|message|</span></span><br><span class="line">    klass = message[<span class="symbol">:klass</span>]</span><br><span class="line">    params = message[<span class="symbol">:params</span>]</span><br><span class="line">    id = message[<span class="symbol">:id</span>]&amp;.to_i</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> params.is_a? String</span><br><span class="line">      params = JSON.parse(params)</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    klass.constantize.new.execute(params.symbolize_keys)</span><br><span class="line">    PendingJob.destroy(id) <span class="keyword">unless</span> id.<span class="literal">nil</span>?</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">rescue</span> =&gt; e</span><br><span class="line">  logger = Logger.new(STDERR)</span><br><span class="line">  logger.error e.inspect</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p>
<p>위의 아키텍처 다이어그램을 보면 알겠지만 SNS로 함수를 실행함으로써 얻는 또 하나의 이점이 있다. 이제 <strong>작업을 예약 없이 바로 백그라운드에서 처리</strong>할 수 있게 됐다. (API에서 바로 SNS 호출)</p>
<p>Lambda만 사용하는 버전에서 회원가입 후 환영 이메일을 발송하는 과정을 생각해 보자. 회원가입을 완료하면 <code>Jobs::SendEmail.schedule()</code>을 사용하여 작업 정보를 데이터베이스에 저장하고, 일정 시간 뒤(최대 5분)에 <code>enqueue_pending_jobs</code> 함수가 작업을 실행하여 메일을 보내게 된다. 물론 백그라운드에서 처리하지 않고 바로 <code>Jobs::SendEmail.execute()</code>를 할 수도 있지만 둘 다 권장하는 방법은 아니다.</p>
<p>SNS까지 함께 사용하는 버전에서는 <code>Jobs::SendEmail.perform()</code>을 실행하면 된다! 🎉</p>
<h2 id="마무리"><a href="#마무리" class="headerlink" title="마무리"></a>마무리</h2><p>지금은 백엔드를 전부 Lambda + SNS로 변경했고, 무료 사용량 내에서 쓰고 있다. 아직 RDS에 매달 $30씩 지불하고 있지만, 이마저도 <a href="https://github.com/Dynamoid/dynamoid" target="_blank" rel="noopener">dynamodb</a>를 사용하면 돈 한 푼 들이지 않고 서비스를 운영할 수 있다. 물론 앞서 말했듯 나는 ActiveRecord와 ActiveSupport를 사랑하기 때문에 (..) 당분간은 이대로 서비스할 것 같다. 가볍게 시작한 글이 배경 설명과 코드 예제까지 들어가 길어졌다. 실제로 작동하는 예시 프로젝트는 <a href="https://github.com/mu29/sns-lambda-background-processing" target="_blank" rel="noopener">Github</a>에서 확인할 수 있다.</p>
]]></content>
      
        <categories>
            
            <category> backend </category>
            
        </categories>
        
        
        <tags>
            
            <tag> background processing </tag>
            
            <tag> serverless </tag>
            
            <tag> lambda </tag>
            
            <tag> sns </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA['실시간 추천엔진 머신한대에 구겨넣기' 50줄로 구현하기]]></title>
      <url>/2019/04/07/50-lines-of-recommendation-engine/</url>
      <content type="html"><![CDATA[<p>추천 시스템에 관심이 생겨 찾아봤다면 한 번쯤은 <a href="https://www.slideshare.net/deview/261-52784785" target="_blank" rel="noopener">실시간 추천엔진 머신한대에 구겨넣기</a>라는 슬라이드를 마주쳤을 거라고 생각한다. 워낙 유명한 발표라 당시 페이스북에서도 많이 공유 되었던 것 같다. 나 역시 씀 : 일상적 글쓰기를 개발하면서 사용자들에게 구독, 혹은 담아 갈 만한 글을 추천해주고 싶었고, 어떤 식으로 구현할 수 있을지 알아보다 이 슬라이드를 발견했다. 처음 1/3 정도까지는 고개를 끄덕이며 술술 읽어 나갔는데, MinHash, LSH 같은 단어가 보이면서 점점 잠이 오더니, 어떻게 다 읽기는 했다만 ‘그래서 어떻게 한다고?’라는 생각을 하며 브라우저를 닫아 버렸다.</p>
<p>그렇게 몇 달간 추천 시스템은 잊고 지내다가, 최근 Cake 앱 개편 작업을 준비하며 홈 화면 개인화(=추천)라는 주제가 회의에서 이야기되었고, 불현듯 한 번 읽고 넘겨버린 이 자료가 생각나 간단하게 구현해 보기로 했다. 본격적으로 개발을 시작하기 전에, 발표에서 나온 개념들을 하나씩 짚고 넘어가 보자.</p>
<h2 id="Jaccard-Similarity"><a href="#Jaccard-Similarity" class="headerlink" title="Jaccard Similarity"></a>Jaccard Similarity</h2><p>발표 자료에 쉽게 설명이 되어 있다. A가 좋아한 상품이 [1, 2, 3],  B가 좋아한 상품이 [1, 2, 4], C가 좋아한 상품이 [1, 4, 5] 일 때 각 사용자들이 좋아한 상품을 기반으로 서로 얼마나 비슷한지 알아보는 것이다. 두 사용자 A, B의 Jaccard similarity는 다음과 같이 측정할 수 있다.</p>
<p>$$J(A,B) = \frac{|A \cap B|}{|A \cup B|}$$</p>
<p>예를 들어, 앞서 말한 A와 B의 Jaccard similarity는 아래와 같이 구할 수 있다.</p>
<p>$$\frac{|A \cap B|}{|A \cup B|} = \frac{|{1, 2}|}{|{1, 2, 3, 4}|} = 0.5$$</p>
<p>Ruby로 간단하게 구할 수도 있다.</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]; b = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>]</span><br><span class="line">(a &amp; b).length / (a <span class="params">| b).length</span></span><br></pre></td></tr></table></figure>
<h2 id="MinHash"><a href="#MinHash" class="headerlink" title="MinHash"></a>MinHash</h2><p>LSH는 발표 자료에 잘 설명이 되어 있는데, MinHash에 관해서는 Jaccard similarity를 유지하는 타입의 LSH라는 것 말고는 별다른 내용이 없다. ‘그래서 MinHash가 구체적으로 뭐지?’ 하는 의문이 들 수 있는데 찾아보면 의외로 간단한 개념이다. n 개의 원소로 이루어진 집합 S에 대하여, 보통 MinHash를 구하기 위해 사용하는 해시 함수는 아래와 같다.</p>
<p>$$h(x) = (a x + b)\bmod p$$</p>
<p>여기서 a와 b는 n보다 작은 임의의 자연수이며, p는 n과 같거나 큰 가장 작은 소수이다.</p>
<p>이전에 설명한 예시를 다시 가져와 보면, 전체 상품이 1 ~ 10까지 있다고 가정하면 n이 10이고, a = 2, b = 8, p = 11로 했을 때, 우리의 첫 번째 해시 함수는 아래와 같을 것이다.</p>
<p>$$h(x) = (2x + 8) \bmod 11$$</p>
<p>이 해시 함수에 사용자의 아이템을 전부 집어넣어 나온 값 중 가장 작은 값이 바로 MinHash 값이다(정확히는 <em>해당 사용자에 대한 이 해시 함수의 MinHash 값</em>). 예시에서 사용자 A의 경우 이 해시 함수를 사용했을 때 MinHash 값이 1, 사용자 B의 경우에도 1, 사용자 C의 경우에는 5가 된다. 그러면 우리는 사용자 A와 B가 같고, C는 다르다고 생각할 수 있다.</p>
<h2 id="Signiture"><a href="#Signiture" class="headerlink" title="Signiture"></a>Signiture</h2><p>MinHash 값을 구하는 과정을 보면 알겠지만, 두 사용자가 서로 다른 아이템을 가지고 있을 때도 MinHash 값은 같을 수 있다. 그래서 실제로 사용할 때는 a, b를 다르게 설정한 해시 함수를 많이 만들어서, MinHash를 여러 개 구하고, 이를 이어 붙여서 사용자의 Signiture를 만든다. 발표 자료에서는 100개를 추천하고 있다. 이렇게 만들어진 Signiture는 사용자 간의 유사도를 구하는데 사용된다. 예를 들어, 사용자 A의 Signiture가 <code>[1, 0, 1, 6, 0]</code>이고, 사용자 B의 Signiture가 <code>[1, 0, 0, 6, 0]</code>이면 둘은 80% 일치한다고 보는 것이다.</p>
<h2 id="Secondary-Index"><a href="#Secondary-Index" class="headerlink" title="Secondary Index"></a>Secondary Index</h2><p>이렇게 구한 Signiture로 사용자 간의 유사도를 구한다는 것은 알겠는데, 추천할 때마다 모든 사용자와 비교해서 비슷한 사용자를 찾는다면 속도에 이점이 전혀 없다. 그래서 발표에서 제시한 것이 Secondary Index이다. 사용자의 각 Signiture와 그 Signiture의 인덱스를 합친 키에, 값을 해당 사용자로 하는 Key-Value 저장소를 만드는 것이다.</p>
<p>글로만 보면 이해하기 어려우니 예시를 통해 더 알아보자. 앞서 예로 든 사용자 A의 Signiture <code>[1, 0, 1, 6, 0]</code>를 각각의 Index와 함께 묶어 키로 만들고, 값에는 사용자 A를 넣어서 Secondary Index를 만든다.</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">'1-0'</span> =&gt; [<span class="string">'A'</span>],</span><br><span class="line">  <span class="string">'0-1'</span> =&gt; [<span class="string">'A'</span>],</span><br><span class="line">  <span class="string">'1-2'</span> =&gt; [<span class="string">'A'</span>],</span><br><span class="line">  <span class="string">'6-3'</span> =&gt; [<span class="string">'A'</span>],</span><br><span class="line">  <span class="string">'0-4'</span> =&gt; [<span class="string">'A'</span>],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>잘 보면, 키가 Signiture-Index로 구성되어 있다. 여기에 사용자 B의 Signiture <code>[1, 0, 0, 6, 0]</code>도 넣어 보자.</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">'1-0'</span> =&gt; [<span class="string">'A'</span>, <span class="string">'B'</span>],</span><br><span class="line">  <span class="string">'0-1'</span> =&gt; [<span class="string">'A'</span>, <span class="string">'B'</span>],</span><br><span class="line">  <span class="string">'1-2'</span> =&gt; [<span class="string">'A'</span>],</span><br><span class="line">  <span class="string">'6-3'</span> =&gt; [<span class="string">'A'</span>, <span class="string">'B'</span>],</span><br><span class="line">  <span class="string">'0-4'</span> =&gt; [<span class="string">'A'</span>, <span class="string">'B'</span>],</span><br><span class="line">  <span class="string">'0-2'</span> =&gt; [<span class="string">'B'</span>],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>사용자 B의 3번째 Signiture인 0이 <code>0-2</code>로 마지막에 들어갔다. 이제 임의의 사용자와 비슷한 사용자를 찾으려면 해당 사용자의 Signiture를 <code>map</code> 함수를 사용하여 Signiture-Index 형태로 변형하고, Secondary Index에서 가져오면 되겠다.</p>
<p>사용자 A의 Signiture <code>[1, 0, 1, 6, 0]</code>를 Signiture-Index 형태로 변형하면 <code>[&#39;1-0&#39;, &#39;0-1&#39;, &#39;1-2&#39;, &#39;6-3&#39;, &#39;0-4&#39;]</code>가 되고, 이 키들을 가지고 Secondary Index 저장소에서 값을 가져오면   <code>[&#39;A&#39;, &#39;B&#39;], [&#39;A&#39;, &#39;B&#39;], [&#39;A&#39;], [&#39;A&#39;, &#39;B&#39;], [&#39;A&#39;, &#39;B&#39;]</code>가 나올 텐데, 여기서 A를 제외하면 비슷한 사용자 B를 빠르게 찾을 수 있는 것이다. 또, 둘의 유사도는 B의 등장 횟수 4를 Signiture의 길이 5로 나눈 80%가 된다.</p>
<h2 id="비슷한-사용자-비슷한-아이템"><a href="#비슷한-사용자-비슷한-아이템" class="headerlink" title="비슷한 사용자, 비슷한 아이템"></a>비슷한 사용자, 비슷한 아이템</h2><p>발표 자료와 이 글을 함께 보고 있으면 이상한 점을 하나 발견할 수 있다. 이쯤이면 발표 자료는 아이템의 Signiture에 관한 설명을 하고 있기 때문이다. (54페이지) 분명히 처음에는 사용자 기반 협업 필터링이었던 것 같은데?</p>
<p>생각해 보면 이 방법은 비슷한 사용자를 추천하는데도 사용할 수 있고, 비슷한 아이템을 추천하는데도 사용할 수 있다. 다만 한 사용자가 100개 이상의 아이템을 선호하는 경우가 많을지, 한 아이템을 100명 이상의 사용자가 선호하는 경우가 많을지 생각해보면 아이템 추천 시스템을 만드는 것이 좀 더 일리 있어 보이기는 하다.</p>
<p>1) 비슷한 사용자를 추천하는 경우에는 임의의 사용자에게 좋아할 만한 아이템을 추천해 줄 수 있고, 2) 비슷한 아이템을 추천하는 경우에는 사용자가 임의의 아이템을 선호한다는 표현을 했을 때, 그와 비슷한 다른 아이템들을 소개해 줄 수 있을 것이다.</p>
<p>원래 만들고자 한 기능이 홈 화면에서 볼 만한 영상을 추천해주는 것이기 때문에 이 글에서는 첫 번째 방법으로 임의의 사용자에게 좋아할 만한 다른 아이템을 추천해 주는 기능을 구현할 예정이지만, 원한다면 반대로 구현해도 좋다.</p>
<h2 id="50줄로-구현하기"><a href="#50줄로-구현하기" class="headerlink" title="50줄로 구현하기"></a>50줄로 구현하기</h2><p>Redis를 사용하는 부분을 제외하고, 발표에서 이야기하는 실시간 추천 엔진이 어떻게 돌아가는 것인지 Ruby로 간단하게 구현해 보자. 마지막의 전체 코드를 제외한 이 글의 모든 코드는 irb를 사용해서 테스트할 수 있도록 작성했다. 맥 사용자라면 터미널에서 irb를 실행하고 복사-붙여넣기만 해도 작동한다. 테스트 데이터는 발표 자료에 나온 것을 그대로 사용하면 되겠다. (14페이지)</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@likes_data = [</span><br><span class="line">  [<span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">  [<span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>], <span class="comment"># 2번째 사용자 (나)</span></span><br><span class="line">  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>],</span><br><span class="line">  [<span class="number">2</span>, <span class="number">5</span>],</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>Signiture의 길이는 10으로 하고, p = 7로 잡아서 MinHash를 구하기 위한 해시 함수를 만들어 보자. Signiture의 길이만큼 해시 함수가 필요하다. a는 소수, b는 2의 배수로 정해서 해시 함수의 결과를 반환하는 함수를 보자. 소수를 쉽게 가져오기 위해 <a href="https://github.com/ruby/prime" target="_blank" rel="noopener">prime</a> 젬을 사용했다.</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">require</span> <span class="string">'prime'</span></span><br><span class="line"></span><br><span class="line">@coefficient = Prime.take(<span class="number">10</span>) <span class="comment"># [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">min_hash</span><span class="params">(index, value)</span></span></span><br><span class="line">  (@coefficient[index] * value.to_i + <span class="number">2</span> * index) % <span class="number">7</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>2번째 사용자의 첫 MinHash 값은</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  min_hash(<span class="number">0</span>, <span class="number">1</span>),</span><br><span class="line">  min_hash(<span class="number">0</span>, <span class="number">4</span>),</span><br><span class="line">  min_hash(<span class="number">0</span>, <span class="number">5</span>),</span><br><span class="line">].min <span class="comment"># = 1</span></span><br></pre></td></tr></table></figure>
<p>이고, 그 다음 Minhash 값은</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  min_hash(<span class="number">1</span>, <span class="number">1</span>),</span><br><span class="line">  min_hash(<span class="number">1</span>, <span class="number">4</span>),</span><br><span class="line">  min_hash(<span class="number">1</span>, <span class="number">5</span>),</span><br><span class="line">].min <span class="comment"># = 0</span></span><br></pre></td></tr></table></figure>
<p>이다. 이런 식으로 구한 2번째 사용자의 Signiture는 <code>[1, 0, 1, 6, 0, 2, 1, 4, 3, 1]</code> 이다. 전체 사용자의 Signiture를 구하는 코드는 다음과 같다.</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@signitures = @likes_data.map <span class="keyword">do</span> <span class="params">|likes|</span></span><br><span class="line">  [*(<span class="number">0</span>...<span class="number">10</span>)].map <span class="keyword">do</span> <span class="params">|i|</span></span><br><span class="line">    likes.map <span class="keyword">do</span> <span class="params">|like|</span></span><br><span class="line">      min_hash(i, like)</span><br><span class="line">    <span class="keyword">end</span>.min</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>각 사용자의 Signiture는 아래와 같다.</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [<span class="number">4</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>],</span><br><span class="line">  [<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">1</span>], <span class="comment"># 2번째 사용자 (나)</span></span><br><span class="line">  [<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">1</span>],</span><br><span class="line">  [<span class="number">3</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>],</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>잠깐 멈춰서 계산을 해보자. 2번째 사용자의 Signiture는 1번째 사용자와 10%, 3번째 사용자와 70%, 4번째 사용자와는 20% 일치한다. 그러므로 우리는 3번째 사용자가 좋아한 아이템 중, 2번째 사용자가 좋아하지 않은 것을 추천해 주면 되겠다. (<code>likes_data[2] - likes_data[1]</code>)</p>
<p>발표 자료에도 나와 있듯, 모든 사용자를 하나하나 비교하는 것은 비효율적이다. Signiture의 위치와 값으로 Secondary Index를 만들어, Secondary Index lookup 만으로 유사도를 계산해 보자. 우선 Signiture를 Secondary Index key로 변환하는 함수를 만들자.</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">signiture_to_key</span><span class="params">(signiture)</span></span></span><br><span class="line">  signiture.map.with_index <span class="keyword">do</span> <span class="params">|sig, index|</span></span><br><span class="line">    <span class="string">"<span class="subst">#&#123;sig&#125;</span>-<span class="subst">#&#123;index&#125;</span>"</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>2번째 사용자의 Signiture를 이 함수에 넣고 돌리면</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">"1-0"</span>, <span class="string">"0-1"</span>, <span class="string">"1-2"</span>, <span class="string">"6-3"</span>, <span class="string">"0-4"</span>, <span class="string">"2-5"</span>, <span class="string">"1-6"</span>, <span class="string">"4-7"</span>, <span class="string">"3-8"</span>, <span class="string">"1-9"</span>]</span><br></pre></td></tr></table></figure>
<p>이렇게 뒤에 Index가 붙게 되는 것을 확인할 수 있다. 다음으로 이렇게 만든 키에 사용자 목록을 값으로 가지는 Secondary Index를 만들어 보자. </p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@secondary_index = &#123;&#125;</span><br><span class="line"></span><br><span class="line">@signitures.map.with_index <span class="keyword">do</span> <span class="params">|signiture, user|</span></span><br><span class="line">  keys = signiture_to_key(signiture)</span><br><span class="line">  keys.each <span class="keyword">do</span> <span class="params">|key|</span></span><br><span class="line">    @secondary_index[key] <span class="params">||</span>= []</span><br><span class="line">    @secondary_index[key] &lt;&lt; user</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>만들어진 Secondary Index 목록은 아래와 같다. 2번째 사용자의 Secondary Index key를 찾기 쉽도록 순서를 약간 바꿨다.</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"1-0"</span>=&gt;[<span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">  <span class="string">"0-1"</span>=&gt;[<span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">  <span class="string">"1-2"</span>=&gt;[<span class="number">1</span>],</span><br><span class="line">  <span class="string">"4-0"</span>=&gt;[<span class="number">0</span>],</span><br><span class="line">  <span class="string">"6-3"</span>=&gt;[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">  <span class="string">"0-4"</span>=&gt;[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">  <span class="string">"2-5"</span>=&gt;[<span class="number">1</span>],</span><br><span class="line">  <span class="string">"1-6"</span>=&gt;[<span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">  <span class="string">"4-7"</span>=&gt;[<span class="number">1</span>],</span><br><span class="line">  <span class="string">"3-8"</span>=&gt;[<span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">  <span class="string">"1-9"</span>=&gt;[<span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">  <span class="string">"1-1"</span>=&gt;[<span class="number">0</span>, <span class="number">3</span>],</span><br><span class="line">  <span class="string">"0-2"</span>=&gt;[<span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">  <span class="string">"2-4"</span>=&gt;[<span class="number">0</span>],</span><br><span class="line">  <span class="string">"0-5"</span>=&gt;[<span class="number">0</span>],</span><br><span class="line">  <span class="string">"0-6"</span>=&gt;[<span class="number">0</span>],</span><br><span class="line">  <span class="string">"1-7"</span>=&gt;[<span class="number">0</span>],</span><br><span class="line">  <span class="string">"1-8"</span>=&gt;[<span class="number">0</span>],</span><br><span class="line">  <span class="string">"0-9"</span>=&gt;[<span class="number">0</span>],</span><br><span class="line">  <span class="string">"1-5"</span>=&gt;[<span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">  <span class="string">"3-7"</span>=&gt;[<span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">  <span class="string">"3-0"</span>=&gt;[<span class="number">3</span>],</span><br><span class="line">  <span class="string">"4-6"</span>=&gt;[<span class="number">3</span>],</span><br><span class="line">  <span class="string">"5-8"</span>=&gt;[<span class="number">3</span>],</span><br><span class="line">  <span class="string">"2-9"</span>=&gt;[<span class="number">3</span>],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>이제 우리가 임의의 사용자를 집어넣으면, 그 사용자와 비슷한 다른 사용자를 반환해 주면 된다. 이미 Secondary Index까지 만들어 두었으니, 할 일은 그저 임의의 사용자의 Signiture를 Secondary Index key로 변환하고, Secondary Index에서 값을 읽어 와서 모두 합치는 것뿐이다. 두 번째 사용자와 비슷한 사용자를 찾는 코드는 다음과 같다.</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">signiture_to_key(@signitures[<span class="number">1</span>]).reduce([]) <span class="keyword">do</span> <span class="params">|users, key|</span></span><br><span class="line">  users &lt;&lt; @secondary_index[key]</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment"># [[1, 2], [1, 2], [1], [0, 1, 2, 3], [1, 2, 3], [1], [1, 2], [1], [1, 2], [1, 2]]</span></span><br></pre></td></tr></table></figure>
<p>각 Signiture 별로 일치하는 사용자 목록을 가져온 것이다. 이제 사용자 아이디의 등장 횟수를 세어 보자.</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">signiture_to_key(@signitures[<span class="number">1</span>]).reduce([]) <span class="keyword">do</span> <span class="params">|users, key|</span></span><br><span class="line">  users &lt;&lt; @secondary_index[key]</span><br><span class="line"><span class="keyword">end</span>.flatten.</span><br><span class="line">  <span class="comment"># [1, 2, 1, 2, 1, 0, 1, 2, 3, 1, 2, 3, 1, 1, 2, 1, 1, 2, 1, 2]</span></span><br><span class="line">  group_by(&amp;<span class="symbol">:itself</span>).</span><br><span class="line">  <span class="comment"># &#123;</span></span><br><span class="line">  <span class="comment">#   1=&gt;[1, 1, 1, 1, 1, 1, 1, 1, 1, 1],</span></span><br><span class="line">  <span class="comment">#   2=&gt;[2, 2, 2, 2, 2, 2, 2],</span></span><br><span class="line">  <span class="comment">#   0=&gt;[0],</span></span><br><span class="line">  <span class="comment">#   3=&gt;[3, 3]</span></span><br><span class="line">  <span class="comment"># &#125;</span></span><br><span class="line">  transform_values(&amp;<span class="symbol">:count</span>)</span><br><span class="line">  <span class="comment"># &#123;1=&gt;10, 2=&gt;7, 0=&gt;1, 3=&gt;2&#125;</span></span><br></pre></td></tr></table></figure>
<p>실행하면 아래와 같이 출력된다.</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="number">1</span>=&gt;<span class="number">10</span>, <span class="number">2</span>=&gt;<span class="number">7</span>, <span class="number">0</span>=&gt;<span class="number">1</span>, <span class="number">3</span>=&gt;<span class="number">2</span>&#125;</span><br></pre></td></tr></table></figure>
<p>자기 자신과는 100% 일치, 3번 사용자와 70% 일치, 1번 사용자와 10% 일치, 4번 사용자와 20% 일치한다. 앞서 우리가 계산한 결과와 같다. 조금 더 욕심을 부려 보자면, 가장 비슷한 한 명을 찾아볼 수 있겠다.</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">signiture_to_key(@signitures[<span class="number">1</span>]).reduce([]) <span class="keyword">do</span> <span class="params">|users, key|</span></span><br><span class="line">  users &lt;&lt; @secondary_index[key]</span><br><span class="line"><span class="keyword">end</span>.flatten.</span><br><span class="line">  group_by(&amp;<span class="symbol">:itself</span>).</span><br><span class="line">  transform_values(&amp;<span class="symbol">:count</span>).</span><br><span class="line">  sort_by &#123; <span class="params">|key, value|</span> -value &#125;.</span><br><span class="line">  <span class="comment"># [[1, 10], [2, 7], [3, 2], [0, 1]]</span></span><br><span class="line">  slice(<span class="number">1</span>)</span><br><span class="line">  <span class="comment"># [2, 7]</span></span><br></pre></td></tr></table></figure>
<p>2번 유저가 70% 일치한다고 나올 것이다. 마지막으로 비슷한 사용자를 기반으로 아이템을 추천해 주는 함수까지 만들어 보자.</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">recommended_for</span><span class="params">(user)</span></span></span><br><span class="line">  neighbor = signiture_to_key(@signitures[user]).reduce([]) <span class="keyword">do</span> <span class="params">|users, key|</span></span><br><span class="line">    users &lt;&lt; @secondary_index[key]</span><br><span class="line">  <span class="keyword">end</span>.flatten.</span><br><span class="line">    group_by(&amp;<span class="symbol">:itself</span>).</span><br><span class="line">    transform_values(&amp;<span class="symbol">:count</span>).</span><br><span class="line">    sort_by &#123; <span class="params">|key, value|</span> -value &#125;.</span><br><span class="line">    slice(<span class="number">1</span>).</span><br><span class="line">    first</span><br><span class="line"></span><br><span class="line">  @likes_data[neighbor] - @likes_data[user]</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># puts recommended_for(1)</span></span><br></pre></td></tr></table></figure>
<p>전체 코드는 다음과 같다.</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">require</span> <span class="string">'prime'</span></span><br><span class="line"></span><br><span class="line">@coefficient = Prime.take(<span class="number">10</span>) <span class="comment"># [2, 3, 5, 7, 11, 13, 17, 19, 23, 29]</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">min_hash</span><span class="params">(index, value)</span></span></span><br><span class="line">  (@coefficient[index] * value.to_i + <span class="number">2</span> * index) % <span class="number">7</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">signiture_to_key</span><span class="params">(signiture)</span></span></span><br><span class="line">  signiture.map.with_index <span class="keyword">do</span> <span class="params">|sig, index|</span></span><br><span class="line">    <span class="string">"<span class="subst">#&#123;sig&#125;</span>-<span class="subst">#&#123;index&#125;</span>"</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">recommended_for</span><span class="params">(user)</span></span></span><br><span class="line">  nearest_neighbor = signiture_to_key(@signitures[user]).reduce([]) <span class="keyword">do</span> <span class="params">|users, key|</span></span><br><span class="line">    users &lt;&lt; @secondary_index[key]</span><br><span class="line">  <span class="keyword">end</span>.flatten</span><br><span class="line">    .group_by(&amp;<span class="symbol">:itself</span>)</span><br><span class="line">    .transform_values(&amp;<span class="symbol">:count</span>)</span><br><span class="line">    .sort_by &#123; <span class="params">|key, value|</span> -value &#125;</span><br><span class="line">    .slice(<span class="number">1</span>)</span><br><span class="line">    .first</span><br><span class="line"></span><br><span class="line">  @likes_data[nearest_neighbor] - @likes_data[user]</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">@likes_data = [</span><br><span class="line">  [<span class="number">2</span>, <span class="number">3</span>],</span><br><span class="line">  [<span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>], <span class="comment"># 2번째 사용자 (나)</span></span><br><span class="line">  [<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>],</span><br><span class="line">  [<span class="number">2</span>, <span class="number">5</span>],</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">@signitures = @likes_data.map <span class="keyword">do</span> <span class="params">|likes|</span></span><br><span class="line">  [*(<span class="number">0</span>...<span class="number">10</span>)].map <span class="keyword">do</span> <span class="params">|i|</span></span><br><span class="line">    likes.map <span class="keyword">do</span> <span class="params">|like|</span></span><br><span class="line">      min_hash(i, like)</span><br><span class="line">    <span class="keyword">end</span>.min</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">@secondary_index = &#123;&#125;</span><br><span class="line"></span><br><span class="line">@signitures.map.with_index <span class="keyword">do</span> <span class="params">|signiture, user|</span></span><br><span class="line">  keys = signiture_to_key(signiture)</span><br><span class="line">  keys.each <span class="keyword">do</span> <span class="params">|key|</span></span><br><span class="line">    @secondary_index[key] <span class="params">||</span>= []</span><br><span class="line">    @secondary_index[key] &lt;&lt; user</span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">puts recommended_for(<span class="number">1</span>)</span><br></pre></td></tr></table></figure>
<p><code>recommended_for</code> 함수의 인자를 변경해 가며 각 사용자가 어떤 아이템을 추천받는지 확인해 볼 수 있다. 여기서 더 나아가면 비슷한 사용자 한 명이 아니라 여러 명을 가져와서 선호 데이터를 더 늘릴 수도 있고, <code>@likes_data</code>, <code>@signitures</code>, <code>@secondary_index</code>를 Redis를 통해 관리할 수도 있다. 여기까지 구현한 코드는 <a href="https://github.com/mu29/dessert" target="_blank" rel="noopener">이곳</a>에서 확인할 수 있다.</p>
]]></content>
      
        <categories>
            
            <category> backend </category>
            
        </categories>
        
        
        <tags>
            
            <tag> recommender system </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Rails 단일 테이블 상속 (STI)]]></title>
      <url>/2018/01/21/rails-single-table-inheritance/</url>
      <content type="html"><![CDATA[<h2 id="단일-테이블-상속-Single-Table-Inheritance-STI"><a href="#단일-테이블-상속-Single-Table-Inheritance-STI" class="headerlink" title="단일 테이블 상속 (Single Table Inheritance, STI)"></a>단일 테이블 상속 (Single Table Inheritance, STI)</h2><p>단일 테이블 상속이란 관계형 데이터베이스에서 객체 지향 프로그래밍의 <em>상속</em>이라는 개념을 사용하기 위한 방법이다. 하나의 테이블에 기본 모델을 상속하는 여러 모델들의 데이터를 저장하고, 테이블의 특정 컬럼을 해당 데이터와 연결될 모델을 구분하기 위해 사용한다.</p>
<h2 id="Active-Record의-CoC-Convention-over-Configuration"><a href="#Active-Record의-CoC-Convention-over-Configuration" class="headerlink" title="Active Record의 CoC (Convention over Configuration)"></a>Active Record의 CoC (Convention over Configuration)</h2><p>Rails(Active Record)에서는 모델이 단일 테이블 상속을 사용하는 경우, <code>type</code> 컬럼을 모델 식별을 위해 사용하는 것이 관례이다.</p>
<p>예를 들어, <code>User</code> 모델을 상속하는 <code>Writer</code> 와 <code>Reader</code> 가 있고, 우리가 STI를 사용하려 한다면, <code>User</code> 모델의 마이그레이션은 <code>type</code> 컬럼을 포함해야 한다.</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CreateUsers</span> &lt; ActiveRecord::Migration[5.1]</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">change</span></span></span><br><span class="line">    create_table <span class="symbol">:users</span> <span class="keyword">do</span> <span class="params">|t|</span></span><br><span class="line">      t.string <span class="symbol">:email</span></span><br><span class="line">      t.string <span class="symbol">:password_digest</span></span><br><span class="line">      t.string <span class="symbol">:type</span> <span class="comment"># STI에 사용될 컬럼</span></span><br><span class="line">      t.timestamps</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<h2 id="STI-사용하기"><a href="#STI-사용하기" class="headerlink" title="STI 사용하기"></a>STI 사용하기</h2><p>이제 <code>User</code> 모델을 상속받는 <code>Writer</code>, <code>Reader</code> 모델을 만들어보자.</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> &lt; ApplicationRecord</span></span><br><span class="line">  ...</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Writer</span> &lt; User</span></span><br><span class="line">  has_many <span class="symbol">:novels</span></span><br><span class="line">  before_destroy <span class="symbol">:can_leave?</span>, <span class="symbol">prepend:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">can_leave?</span></span></span><br><span class="line">    <span class="keyword">if</span> novels.count &gt; <span class="number">0</span></span><br><span class="line">      errors[<span class="symbol">:base</span>] &lt;&lt; <span class="string">'연재중인 소설이 있어서 탈퇴할 수 없습니다.'</span></span><br><span class="line">      throw <span class="symbol">:abort</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">    <span class="literal">true</span></span><br><span class="line">  <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Reader</span> &lt; User</span></span><br><span class="line">  has_many <span class="symbol">:payments</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
<p>둘 다 <code>User</code>의 속성과 함수를 가지지만, <code>Reader</code> 는 탈퇴 조건이 따로 없는 반면, <code>Writer</code> 의 경우 연재중인 소설이 있는 경우에는 탈퇴할 수 없도록 설정되어 있다. <code>Writer</code> 와 <code>Reader</code> 모델은 따로 테이블을 가지지 않고, <code>User</code> 테이블에 <code>type: &#39;Writer&#39;</code> 혹은 <code>type: Reader</code> 로 저장된다.<br>생성은 <code>User#create</code> 혹은 <code>Reader#create</code> 로 가능하다. <code>User#create</code> 로 생성하는 경우 <code>type</code> 을 명시해야 한다.</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">User.create(<span class="symbol">email:</span> <span class="string">'mu29@yeoubi.net'</span>, <span class="symbol">password:</span> <span class="string">'1234'</span>, <span class="symbol">type:</span> <span class="string">'Reader'</span>)</span><br><span class="line">Reader.create(<span class="symbol">email:</span> <span class="string">'mu29@yeoubi.net'</span>, <span class="symbol">password:</span> <span class="string">'1234'</span>)</span><br></pre></td></tr></table></figure>
<h2 id="STI-관련-이슈"><a href="#STI-관련-이슈" class="headerlink" title="STI 관련 이슈"></a>STI 관련 이슈</h2><p>이러한 Rails의 STI에 관한 관례를 알지 못하고 <code>type</code> 컬럼을 사용하면 아래와 같은 오류가 발생하게 된다.</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LoadError:</span><br><span class="line">  Unable to autoload constant Writer, expected /Users/injung/Github/ssm-api/app/models/writer.rb to define it</span><br></pre></td></tr></table></figure>
<p><code>type</code> 컬럼은 쓰고 싶지만, STI를 쓰고 싶지 않다면 해당 설정을 비활성화 할 수 있다.</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span> &lt; ApplicationRecord</span></span><br><span class="line">  <span class="keyword">self</span>.inheritance_column = <span class="symbol">:_type_disabled</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> backend </category>
            
        </categories>
        
        
        <tags>
            
            <tag> rails </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[소프트웨어 마에스트로 지원 후기]]></title>
      <url>/2015/06/19/sw-maestro-6th-apply/</url>
      <content type="html"><![CDATA[<p>참 오래도 기다렸다. 2011년, 막 고등학교에 들어갔을 때 자주 활동하던 카페에 글이 하나 올라왔다. 소프트웨어 마에스트로 2기 과정에 지원하신단다. 마에스트로라, 얼마나 대단한 인재를 양성하는지 궁금해졌다. 모집 요강은 어렵지 않게 찾을 수 있었다. 내 주의를 끈 것은 지원금이었다. 하고싶은 공부를 하면서 돈을 받다니, 역시 뭐든지 잘 하면 도움이 되는구나.</p>
<p>그렇지만 나는 선뜻 지원서를 쓰지 못했다. 내 실력에 자신이 없었기 때문이었다. 매년 지원 공고를 보고, 지원을 망설였지만 아직은 아니라는 생각이 자꾸 발목을 잡았다. 그렇게 4년이라는 시간이 흘러 21살이 됐다. 소프트웨어 마에스트로 말고도 대학 졸업 전까지 해보고 싶은 것들이 많았다. 더 이상 망설이면 너무 늦어버릴 것 같았다.</p>
<p>지원 마감까지는 아직 일주일 정도의 시간이 남아 있었다. 급한 대로 대학 입시 때 작성했던 자기소개서를 이리저리 뜯어고쳤다. 할 말은 산더민데, 글자 수 제한은 빡빡했다. 문득 이렇게 짧은 글 안에 내가 겪은 경험들을 다 녹여낼 수 있을지, 또 그걸 보고 지원자를 제대로 평가할 수 있을지 궁금해졌다. 몇몇 블로그의 후기 글을 찾아 본 바로는 실적에 관심이 많다고 하던데, 자기소개서의 분량을 고려해봤을 때 아마 포트폴리오에서 서류 당락이 결정되지 않나 싶다. 나는 개발하여 일년째 서비스 중인 게임과 약 세달간 개발한 게임 엔진, 그리고 비교적 최근에 개발한 랜덤 채팅 서비스를 썼다.</p>
<p>마감을 2~3일 앞두고는 센터에서 전화가 하루에 한 번 꼴로 왔다. 금요일이 마감이고, 당일은 지원자가 몰려 접속이 원활하지 않으니 미리 제출해 달라는 내용이었다. 이쪽도 실적을 내야 하니 어떻게 해서든 지원자 수를 끌어올려야 하나 보다.</p>
<p>지원하고 나서는 학교 생활에 치여 발표도 잊고 지냈는데, 어느 날 점심때 즈음 일어나 핸드폰을 확인하니 문자가 와 있었다. 서류 전형에 합격했으니 면접을 보러 오란다. 솔직히 말해서 나는 면접에는 어느 정도 자신감이 있었다. 아직까지 면접 경험이 많지 않아 그런 것인지는 모르겠다만, 서류에서 다 써내지 못한 나의 능력과 열정을 어필하는 것이 좋았다. 그런데 이번 기수부터는 면접 과정에 집단 토의라는게 추가됐다. 생면부지의 남들과 토의를 한다는 것은 꽤 큰 부담이었다.</p>
<p>아버지에게 조언을 구했더니, 집단토의는 토의를 이끄는 사람이 점수를 잘 받으니 다른 사람들의 의견을 정리해서 말해보라 하셨다. 그런데 막상 토의를 하게 되니 말을 꺼내는 것조차 쉽지 않았다. 한 사람의 말이 끝나면 생각을 정리할 틈도 없이 다른 사람이 말을 이어나갔다. 처음에는 적잖이 당황해서 말은 하지 못하고, 다른 사람들의 의견을 정리하고 내 논리도 다듬었다. 다행히 중간부터는 무리 없이 끼어들어 이야기 할 수 있었다. 총 8명 중 세 분은 옷도 정장을 차려입고 오셨는데, 대학원생 혹은 군필 정도로 나이가 꽤 있어 보였고 의견도 거침없이 내셨다. 아마 이분들이 가장 좋은 점수를 받게 되지 않을까 싶다.</p>
<p>3일 뒤에는 코딩 테스트와 면접을 봤다. 준비된 문제가 넉넉잡아 100개는 되어 보였다. 코딩 테스트는 세 명이서 같은 문제를 풀게 되어 있는데, 셋 중 한 명이 문제를 뽑고 다 같이 그 문제를 푸는 방식이다. 비주얼 스튜디오와 이클립스가 있었고, 들은 바로는 파이썬도 깔려있다고 한다. 문제는 그렇게 어렵지 않았다. 어떤 언어를 쓸지 약간 고민하다 자바로 만들고 난 뒤, 시간이 남아 C#으로도 해보다 주어진 시간이 끝났다. 참고로 내 경우 코딩 테스트는 결과만 확인하고 별다른 질문 없이 끝났다.</p>
<p>면접장에 들어가 인사를 하고 발표를 시작했다. 발표는 서류에 담지 못했던 내용 위주로 준비했다. 창업 팀 경험과 프로젝트들, 그리고 프로그래밍을 시작한 과정을 담았다. 끝내고 나니 프레젠테이션을 깔끔하게 잘 만들었다는 이야기와 함께, 발표를 준비해온 사람이 많지 않다고 하셨다. 그러니 혹시 이 글을 보고 소프트웨어 마에스트로에 지원하려는 분은 발표를 준비해가길 바란다. 가산점이 있을 지도 모르니까!</p>
<p>면접은 주로 포트폴리오로 냈던 프로젝트와 향후 계획에 관한 내용이었다. 게임은 유저 수가 얼마나 되는지, 게임 엔진은 내가 얼마나 노력해서 만들었는지 어필해보라고 하셨고, 채팅 서비스에서는 프로토콜 관련 질문을 하셨는데 내가 아는 부분이 아니어서 잘 모르겠다고 대답했다. 프로젝트를 몇 명이서 작업했는지는 꼭 한번씩 물어보셨다.</p>
<p>지원자 중 지원금만 받고 실제 프로젝트에 참여하지 않는 사람이 많아서 그런지 향후 계획에서도 여러가지 질문이 나왔다. 나는 내 목표는 3단계의 5천만원이니 걱정하지 않으셔도 된다고 말씀드렸다. 면접관 중 한분은 끈질기게 휴학을 권하셨다. 본래 2학기에 12학점만 듣고 주 3~4일 정도 서울에 올라올 계획이었는데, 시간을 많이 써야 한다면 휴학도 할만한 것 같다. 학점도 그리 잘 나온 편이 아니라 오히려 솔깃했다.</p>
<p>상당한 압박 면접이라고 들었는데 어차피 떨어질 거라 그런 것인지, 그 반대인지는 모르겠으나 나는 꽤 편안하게 본 것 같다. 이렇게 4년의 기다림이 끝이 났다. 대단하지도 않은 이야기를 참 길게도 썼다. 모쪼록 좋은 결과가 나오길 바란다.</p>
]]></content>
      
        <categories>
            
            <category> diary </category>
            
        </categories>
        
        
        <tags>
            
            <tag> software-maestro </tag>
            
            <tag> interview </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
